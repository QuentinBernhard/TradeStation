Inputs : 
	P1((4*C+H+L)/6),
	L1(5),
	stdDevLength(50),
	stdDevFactor(1),
	Length(125), 			//Length du xAv
	StochLength( 21 ), 
	SmoothingLength1( 21 ), 
	SmoothingLength2( 5 ), 
	SmoothingType( 2 ),
	stoploss(25000),		//perte max par trade
	coefShares(0.5),		//part de shares qui sont vendus au profit take
	coefProfit(2),			//Si vaut 2 alors profit take se fait à deux fois le risque initial, etc ...
	stratType(0);			// 0 = filtre xAv, 1 = filtre xAv + stoc, 2 = xAv et profit take, 3 = xAv, stoc et profit take
			
vars : 	
	ma(0),	
	maa1(0),
	maa2(0),
	maa(0),
	Li(0),	
	Le(0),
	upperEnvelopeLine(0),
	lowerEnvelopeLine(0),
	upperEnvelopeLine1(0),
	lowerEnvelopeLine1(0),
	bullPower(0),
	bearPower(0),
	maxPower(0),
	percentPenetration(0),
	stdDevToUse(0),
	count(0),
	N(0),
	N1(0),
	N2(0),
	N3(0),
	M(0),
	M1(0),
	M2(0),
	M3(0),
	HH(0),
	LL(0),
	Dimen(0),
	alpha(0),
	FiltLi(0),
	FiltLe(0),
	dernier_indice(0),
	state("bearish"),
	xAv(0),  
	strat(1), 
	ind(0), 
	j(0),
	short_prise(False), 
	long_prise(False),
	nbreshares(0),
	oFastK( 0 ), 
	oFastD( 0 ), 
	oSlowK( 0 ), 
	oSlowD( 0 ),
	stoc(0),
	pLong(0),
	pShort(0), 
	nbrShares(0), 
	targetProfitLong(0),
	targetProfitShort(0);

/////////////////////////////////////////////////////////////////
		
//CALCUL DES ENVELOPPES POUR LE STOPLOSS ET PRISE DE POSITION	
	
/////////////////////////////////////////////////////////////////

Le = L1;
Li=2;
N=Li;
M=Le;

N3 = (Highest(High, N) - Lowest(Low, N)) / N;
HH = High;
LL = Low;
For count = 0 to N / 2 - 1 begin
	If High[count] > HH then HH = High[count];
	If Low[count] < LL then LL = Low[count];
End;
N1 = (HH - LL) / (N / 2);
HH = High[N / 2];
LL = Low[N / 2];
For count = N/2 to N - 1 begin
	If High[count] > HH then HH = High[count];
	If Low[count] < LL then LL = Low[count];
End;
N2 = (HH - LL) / (N / 2);
If N1 > 0 and  N2 > 0 and N3 > 0 then Dimen = (Log(N1 + N2) - Log(N3)) / Log(2);
alpha = ExpValue(-4.6*(Dimen - 1));
If alpha < .01 then alpha = .01;
If alpha > 1 then alpha = 1;

FiltLi = alpha*P1  + (1 - alpha)*FiltLi[1];
If CurrentBar < N + 1 then FiltLi = P1 ;


M3 = (Highest(High, M) - Lowest(Low, M)) / M;
For count = 0 to M / 2 - 1 begin
	If High[count] > HH then HH = High[count];
	If Low[count] < LL then LL = Low[count];
End;
M1 = (HH - LL) / (M / 2);
HH = High[M / 2];
LL = Low[M / 2];
For count = M/2 to M - 1 begin
	If High[count] > HH then HH = High[count];
	If Low[count] < LL then LL = Low[count];
End;
N2 = (HH - LL) / (M / 2);
If M1 > 0 and  M2 > 0 and M3 > 0 then Dimen = (Log(M1 + M2) - Log(M3)) / Log(2);
alpha = ExpValue(-4.6*(Dimen - 1));
If alpha < .01 then alpha = .01;
If alpha > 1 then alpha = 1;

FiltLe = alpha*P1  + (1 - alpha)*FiltLe[1];
If CurrentBar < M + 1 then FiltLe = P1 ;

maa1 = (AdaptiveMovAvg( P1 ,Li, Li, Li)+ 2*filtLi)/3;
maa2 = (AdaptiveMovAvg( P1 ,Le, Le, Le)+ 2*filtLe)/3;
ma = AdaptiveMovAvg((maa1+maa2)/2,Le,Le,Le);
									//xaverage et adaptativemovavg sont linéaires
bullPower = absValue(high-ma);
bearPower = absValue(low-ma);
maxPower = maxList(bullPower, bearPower);
percentPenetration = maxPower / ma;
stdDevToUse = AdaptiveMovAvg(stdDevS(percentPenetration, stdDevLength),Le,Le,Le);
upperEnvelopeLine = AdaptiveMovAvg(ma* (1+(stdDevFactor*stdDevToUse)),Le,Le,Le);
lowerEnvelopeLine = AdaptiveMovAvg(ma* (1-(stdDevFactor*stdDevToUse)),Le,Le,Le);
upperEnvelopeLine1 = AdaptiveMovAvg(ma* (1+(stdDevFactor/4*stdDevToUse)),Le,Le,Le);
lowerEnvelopeLine1 = AdaptiveMovAvg(ma* (1-(stdDevFactor/4*stdDevToUse)),Le,Le,Le);


/////////////////////////////////////////////////////////////////

//calcul de l'état du marché (blanc au dessus de rouge ou inversement)

/////////////////////////////////////////////////////////////////


dernier_indice = 0;

if  P1<=lowerEnvelopeLine then  
	state = "bearish";

if  P1>upperEnvelopeLine then
	state = "bullish";

if P1>lowerEnvelopeLine and P1<=upperEnvelopeLine then Begin
	while P1[dernier_indice] > lowerEnvelopeLine[dernier_indice] and P1[dernier_indice] <= upperEnvelopeLine[dernier_indice] and dernier_indice < 20 Begin
		dernier_indice  = dernier_indice + 1;
		if P1[dernier_indice] <= lowerEnvelopeLine[dernier_indice] Then
			state = "bearish";
			lowerEnvelopeLine1 = lowerEnvelopeLine1[dernier_indice];
		if P1[dernier_indice] > upperEnvelopeLine[dernier_indice] Then
			state = "bullish";
			upperEnvelopeLine1 = upperEnvelopeLine1[dernier_indice];
	end;
end;




/////////////////////////////////////////////////////////////////

//Ajout de la condition de prise ou pas détaillée dans l'excel

/////////////////////////////////////////////////////////////////

stoc = Stochastic(High, Low, Close, StochLength, SmoothingLength1, SmoothingLength2, SmoothingType, oFastK, oFastD, oSlowK, oSlowD);
xAv = xaverage ((Highest (High,Length)+Lowest (Low, Length))/2,(Length));	
	


/////////////////////////////////////////////////////////////////

//stratType = 0, filtre xAv et reset avec deux points blancs égaux et pas de profit take 

///////////////////////////////////////////////////////////////// LONG

if stratType = 0 or stratType = 2 then Begin

	pLong = pLong[1];
	long_prise = False;						
	
	if Low <= lowerEnvelopeLine1[dernier_indice + 1] Then
		pLong = 0;
	if dernier_indice > 0 Then
		pLong = 0;
	
	if Close >= upperEnvelopeLine[dernier_indice] and state = "bullish" then Begin
		if Close >= xAv then Begin
			if pLong = 0 Then
				long_prise = True;
		end
		else 
			pLong = 1;
	end;
	
///////////////////////////////////////////////////////////////////////////// SHORT
	
	pShort = pShort[1];	
	short_prise = False;		//permet de faire une sorte de variable globale, qui peut changer à chaque bar
	
	if High >= upperEnvelopeLine1[dernier_indice + 1] Then
		pShort = 0;
	if dernier_indice > 0 Then
		pShort = 0;
	
	
	if Close <= lowerEnvelopeLine[dernier_indice] and state = "bearish" then Begin
		if Close <= xAv then Begin
			if pShort = 0 Then
				short_prise = True;
		end
		else
			pShort = 1;
	end;

end;


/////////////////////////////////////////////////////////////////

//stratType = 1, filtre xAv et stoc, reset avec deux points blancs égaux et pas de profit take

///////////////////////////////////////////////////////////////// LONG

if stratType = 1 or stratType = 3 then Begin

	pLong = pLong[1];
	long_prise = False;						
	
	if Low <= lowerEnvelopeLine1[dernier_indice + 1] and state = "bullish" Then
		pLong = 0;
	if Low <= lowerEnvelopeLine[dernier_indice] and state = "bearish" Then
		pLong = 0;
	if dernier_indice > 0 Then
		pLong = 0;
	
	if Close >= upperEnvelopeLine[dernier_indice] and state = "bullish" then Begin
		if Close >= xAv and oSlowK > oSlowD then Begin
			if pLong = 0 Then
				long_prise = True;
		end
		else 
			pLong = 1;
	end;
	
///////////////////////////////////////////////////////////////////////////// SHORT
	
	pShort = pShort[1];	
	short_prise = False;		//permet de faire une sorte de variable globale, qui peut changer à chaque bar
	
	if High >= upperEnvelopeLine1[dernier_indice + 1] and state = "bearish" Then
		pShort = 0;
	if High >= upperEnvelopeLine[dernier_indice] and state = "bullish" Then
		pShort = 0;
	if dernier_indice > 0 Then
		pShort = 0;
	
	
	if Close <= lowerEnvelopeLine[dernier_indice] and state = "bearish" then Begin
		if Close <= xAv and oSlowK < oSlowD then Begin
			if pShort = 0 Then
				short_prise = True;
		end
		else
			pShort = 1;
	end;

end;






if stratType = 0 or stratType = 1 then begin

		
	if long_prise = True Then Begin
		if Marketposition = -1 Then
			buytocover ("pour long 1") this bar on close;
		if Marketposition = 0 Then
			buy (stoploss/((Close - lowerEnvelopeLine1[dernier_indice + 1])*Bigpointvalue)) Shares this bar on close;
	
	end;
 	
	sell ("stop long 1") next bar at lowerEnvelopeLine1[dernier_indice + 1] Stop;
	
	
	
	if short_prise = True Then Begin
		if Marketposition = 1 Then
			sell ("pour short 1") this bar on close;
		if Marketposition = 0 Then Begin
			sellshort ((stoploss/((upperEnvelopeLine1[dernier_indice + 1] - Close)*Bigpointvalue))) Shares this bar on close;
		end;
	end;
	
	Buytocover ("stop short 1") next bar at upperEnvelopeLine1[dernier_indice + 1] Stop; 
end;






if stratType = 2 or stratType = 3 then Begin			//Variation avec les profit take
	
	if long_prise = True Then Begin
		if Marketposition = -1 Then
			buytocover ("pour long 2") this bar on close;
		if Marketposition = 0 Then
			nbrShares = ((stoploss/((Close - lowerEnvelopeLine1[dernier_indice + 1])*Bigpointvalue)));
			buy nbrShares Shares this bar on close;
	end;
 
 	targetProfitLong = Close[Barssinceentry] + coefProfit*(Close[Barssinceentry] - lowerEnvelopeLine1[dernier_indice[Barssinceentry] + 1]);	
	Sell ("PT long") coefShares*nbrShares Shares next bar at targetProfitLong Limit;
	sell ("stop long 2") next bar at lowerEnvelopeLine1[dernier_indice + 1] Stop;
	
	
	
	if short_prise = True Then Begin
		if Marketposition = 1 Then
			sell ("pour short 2") this bar on close;
		if Marketposition = 0 Then Begin
			nbrShares = ((stoploss/((upperEnvelopeLine1[dernier_indice + 1] - Close)*Bigpointvalue)));
			sellshort nbrShares Shares this bar on close;
		end;
	end;
	
	targetProfitShort =  Close[Barssinceentry] - coefProfit*(upperEnvelopeLine1[dernier_indice[Barssinceentry] + 1] - Close[Barssinceentry]);
	BuyToCover ("PT short") coefShares*nbrShares Shares next bar at targetProfitShort Limit;
	Buytocover ("stop short 2") next bar at upperEnvelopeLine1[dernier_indice + 1] Stop;

end;
	

//strat type 2 : prise de profit total à un certain point : 2 fois de risque initial
//3 : prise de profit partiel
//recherche 